# Нотатки для розробника: Архітектура та Концепції "Малювальника"

Цей документ є доповненням до основної документації та дорожньої карти. Його мета — пояснити ключові архітектурні рішення ("чому так зроблено"), розкрити внутрішні механізми та надати практичні інструкції для майбутніх розробників.

---

## 1. Архітектурні рішення та їх обґрунтування

Вибір технологій та підходів є фундаментом, що визначає гнучкість та масштабованість додатку.

-   **`Electron`:** Обраний для забезпечення глибокої інтеграції з операційною системою (нативні меню, діалоги, робота з файлами), що є критичним для професійного десктопного додатку.

-   **`TypeScript`:** Використовується для забезпечення типізації, що значно підвищує надійність коду, спрощує рефакторинг та робить велику кодову базу керованою.

-   **`JSTS (JavaScript Topology Suite)`:** Це порт промислової бібліотеки `JTS` на Java. Обраний для всіх складних геометричних операцій (перетин, об'єднання, буферизація), оскільки самостійна реалізація таких алгоритмів є надзвичайно складною та схильною до помилок. `JSTS` гарантує математичну точність та надійність для таких команд, як `Trim`, `Offset`, `Fillet`.

-   **`XState`:** Використовується для управління логікою складних, багатоетапних команд. Замість нагромадження `if/else` та змінних-прапорців (`isDrawing`, `step = 1`, `step = 2`...), ми описуємо поведінку команди як формальний скінченний автомат. Це робить логіку декларативною, передбачуваною та легкою для візуалізації й розширення.

-   **`Cassowary.js`:** Це солвер (вирішувач) лінійних рівнянь. Він є серцем **параметричного скетчера**. Коли ви додаєте обмеження ("горизонтальність", "паралельність", "довжина"), ви, по суті, додаєте нові рівняння в систему. `Cassowary.js` знаходить розв'язок цієї системи, що дозволяє геометрії динамічно перебудовуватися при перетягуванні точок.

## 2. Пояснення ключових концепцій

### Tool vs. Command

-   **`Tool` (Інструмент):** Це простий обробник подій для базових, одноетапних дій. Наприклад, `PanTool`, `DoorTool` (один клік для створення), `SelectTool` (хоча він і складний, але його основна логіка не є послідовністю кроків). `App.activeTool` завжди вказує на поточний інструмент.
-   **`Command` (Команда):** Це складний, багатоетапний процес, що управляється `CommandManager` та реалізований через `XState`. Коли команда активна, вона "перехоплює" на себе роль `App.activeTool`, отримуючи всі події вводу. Приклади: `TRIM`, `LINE`, `BLOCK`.

### Життєвий цикл рендерингу

1.  Дія користувача (клік, перетягування) змінює стан одного або кількох `SceneObject`.
2.  Після зміни викликається `App.draw()`.
3.  `CanvasController.draw()` очищує полотно та готує контекст (застосовує `pan` та `zoom`).
4.  Викликається `App.getVisibleObjectsSortedForRender()`, який повертає список об'єктів для відмальовки з урахуванням видимості шарів та правильного порядку (напр., штрихування малюється раніше за стіни).
5.  Для кожного об'єкта зі списку викликається його метод `.draw(ctx, ...)`.
    -   **Особливість для стін:** Стіни малюються у два проходи (`drawFill`, а потім `drawStroke`) для коректного "вирізання" отворів дверима/вікнами.

### Серіалізація (`toJSON` / `fromJSON`)

Це критично важливий механізм для:
-   **Збереження/завантаження проєктів:** `App.serializeScene()` збирає `toJSON()` з усіх об'єктів та стилів.
-   **Історія змін (Undo/Redo):** `HistoryManager` зберігає повний знімок сцени у вигляді JSON-рядка.
-   **Копіювання/вставка:** Буфер обміну зберігає `toJSON()` виділених об'єктів.

**Важливо:** При додаванні нового `SceneObject` необхідно реалізувати обидва методи (`toJSON` та статичний `fromJSON`) і зареєструвати його в `src/scene/factory.ts`.

## 3. Практичні інструкції ("Cookbook")

### Як додати новий `SceneObject`

1.  **Створити клас:** Створіть новий файл у `src/scene/`, наприклад, `MyObject.ts`. Клас має реалізовувати інтерфейс `SceneObject`.
2.  **Реалізувати методи:** Найважливіші — `draw()`, `contains()`, `getBoundingBox()`, `move()`, `clone()`, `toJSON()` та статичний `fromJSON()`.
3.  **Зареєструвати у фабриці:** Додайте ваш клас у `src/scene/factory.ts`.
4.  **Оновити `PropertiesController`:** Додайте логіку для відображення та редагування властивостей вашого об'єкта.
5.  **Додати іконку:** Створіть іконку для інструменту та додайте її у `index.html`.
6.  **(Опціонально) Створити `Tool`:** Якщо об'єкт створюється через інтерактивну дію, створіть для нього інструмент у `src/tools/`.

### Як додати нову команду (`Command`)

1.  **Створити машину станів:** Розробіть логіку команди за допомогою `XState` (див. `src/commands/line-command.ts` як приклад).
2.  **Створити клас команди:** Створіть новий файл у `src/commands/`. Клас має реалізовувати `Command` та містити логіку `XState`.
3.  **Зареєструвати команду:** Додайте команду та її аліаси в `CommandManager.startCommandByName()`.
4.  **Додати кнопку:** Додайте кнопку на відповідну панель інструментів у `panels/` та підключіть її в `ToolbarController`.

## 4. Поради з відладки

-   **Проблеми з рендерингом після завантаження/undo:** Найімовірніша причина — помилка в методах `toJSON` або `fromJSON` одного з об'єктів. Перевірте, що всі властивості, які впливають на вигляд, коректно серіалізуються та десеріалізуються.
-   **Команда не працює або поводиться дивно:** Використовуйте візуалізатор для `XState` (напр., Stately.ai's visualizer), щоб побачити, в якому стані "застрягла" ваша команда і чому не відбувається перехід.
-   **Неправильно працює обрізка/зміщення:** Проблема, скоріш за все, в `JSTS`. Використовуйте `console.log(jstsGeometry.toString())` для виведення геометрії у форматі WKT (Well-Known Text), який можна візуалізувати в онлайн-інструментах, напр., QGIS.

## 5. Ідеї для майбутніх покращень (Технічний борг)

-   **Рефакторинг `SelectTool`:** Його внутрішній стан (`state`) є досить складним і може бути переписаний на `XState` для більшої надійності.
-   **Продуктивність:** Для проєктів з тисячами об'єктів варто дослідити впровадження просторової індексації (напр., Quadtree) для прискорення пошуку об'єктів під курсором та об'єктної прив'язки.
-   **UI-компоненти:** Для складних панелей (менеджери стилів) можна розглянути перехід на легко-ваговий UI-фреймворк (напр., Svelte, Lit) замість ручної маніпуляції DOM для спрощення розробки.
-   **WebAssembly (WASM):** "Важкі" обчислення з `JSTS` або `Cassowary` в майбутньому можна перенести на Rust/C++ та скомпілювати у WASM для досягнення нативної продуктивності.
